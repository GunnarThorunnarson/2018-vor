<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="verkefni.css">
  </head>
  <body>
    <div class="wrap">
    <h1>FORR3RR05DU — Verkefni 1</h1>
    <p>Neptúnus Egilsson<br>
    Vor 2018</p>
    <ul>
      <li ><a href="#2.1">russian vs naive algorithm</a> </li>
      <li ><a href="#2.2">quickfind</a> </li>
      <ol style="list-style: lower-alpha" start="3">
        <li ><a href="#2.2c">trén teiknuð</a> </li>
        <li value="5"><a href="#2.2e">hvað er að kóðanum?</a> </li>
        <li ><a href="#2.2f">víxlun á root(p) og root(q)</a> </li>
        <li ><a href="#2.2g">samanburður aðferða</a> </li>
      </ol>
    </ul>
    <hr>
    <section id="2.1">
      <h2>2.1 — russian vs naive algorithm</h2>
      <p>Bæði föllin vinna úr formúlunni foo * bar + baz = niðurstaða, þar sem foo og bar eru færibreyturnar og baz, sem byrjar í 0, er skilað í endann. Bæði föllin standast þessa formúlu eftir hverja einustu lykkju. <br />
      Naive fallið leggur bar saman við baz foo sinnum, sem þýðir að það vex á línulegan hátt m.v. foo.<br />
      Russian fallið brýtur verkefnið niður. Við getum teiknað þetta upp einhvernvegin svona:<br />
      foo * bar = bar + bar + bar + … + bar, foo sinnum. Ef foo er jöfn tala, þá er hægt að líta á vandann þannig: 2 * (bar + bar + … + bar), foo/2 sinnum. <br />
      Ef að foo er oddatala þurfum við bara að taka einn bar út fyrir jöfnuna og draga einn frá foo.<br />
      Fjöldi aðgerða sem þarf til að klára keyrslu á því er ⎣log₂foo⎤+1, eða hversu oft má helminga foo (rúnnað niður) þar til að niðurstaðan gefur 0.</p>
      <p>Þessi vöxtur, linear vs. logarithmic, þýðir að tiltölulega smáar tölur eins og 2²³ margfaldaðar með naive geta tekið um þrjár sekúndur í margföldun, meðan russian fallið fer ekki yfir 2ms í margföldun á tölum eins og 2⁹⁹⁹. Russian fallið er því margfalt hraðara.</p>
      <p></p>
    </section>
    <section id="2.2">
      <h2>1.2 — Shortest path</h2>
      <p><a href="https://github.com/neptunus/unionfind">Kóði fyrir þetta verkefni</a> var unninn í C#</p>
    </section>
    <section id="2.2c">
      <h3>c. trén teiknuð</h3>
      <p>Quickfind má tákna svona : <code>{0} {1,2} {3,4,8,9} {5,6} {7}</code>.</p>
      <div class="images">
        <a href="static/unionfind.png"><img class="single" src="static/unionfind.png"></img></a>
      </div>
    </section>
    <section id="2.2e">
      <h3>e. Hvað er að kóðanum?</h3>
      <p>Það þarf að fanga upprunalegu gildi id[p] og id[q] áður en lykkjan byrjar. Þau gildi geta breyst þegar i er jafnt og p eða q og veldur því skekkjum.</p>
      <p>Annars er lika óþarfa lína: count-- vísar í breytu sem er ekki notuð. </p>
    </section>
    <section id="2.2f">
      <h3>f. víxlun á root(p) og root(q)</h3>
      <p>Samkvæmt prufugögnunum úr c) - lið og prufugögnunum úr kennsluefninu verða trén eins í laginu þó id[root(p)] og id[root(q)] sé víxlað — en tölurnar fara ekki á sömu staði.</p>
      <div class="images">
        <a href="static/weighted_switch.png"><img class="single" src="static/weighted_switch.png"></img></a>
      </div>
    </section>
    <section id="2.2g">
      <h3>g. samanburður aðferða</h3>
      <p>todo!</p>
    </section>
    <hr>
    <footer><p>♆</p></footer>
  </div>
  </body>
</html>
